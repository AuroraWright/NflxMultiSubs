const acorn = require('acorn');

(() => {

// wraper console.xxx() to add prefix
const prefix = 'NflxMultiSubs>';
const console = {
  log: (...args) => window.console.log(prefix, ...args),
  warn: (...args) => window.console.warn(prefix, ...args),
  error: (...args) => window.console.error(prefix, ...args),
};


////////////////////////////////////////////////////////////////////////////////


// updated when we got `<script src...>` in the observer
let origPlayerUrl, origPlayerVersion;

window.addEventListener('load', () => {
  let scriptElem = document.createElement('script');
  scriptElem.setAttribute('type', 'text/javascript');
  scriptElem.textContent = `(() => {
      window.__originalPlayerUrl = ${JSON.stringify(origPlayerUrl)};
      window.__originalPlayerVersion = ${JSON.stringify(origPlayerVersion)};
      window.__nflxMultiSubsExtId = ${JSON.stringify(chrome.runtime.id)};
    })();`;
  document.body.appendChild(scriptElem);

  const scriptsToInject = ['nflxmultisubs.min.js'];
  scriptsToInject.forEach(scriptName => {
    const scriptElem = document.createElement('script');
    scriptElem.setAttribute('type', 'text/javascript');
    scriptElem.setAttribute('src', chrome.extension.getURL(scriptName));
    document.head.appendChild(scriptElem);
    console.log(`Injected: ${scriptName}`);
  });
});


// -----------------------------------------------------------------------------


// Match sub-tree pattern on the given AST (return on any one match)
// ast: JavaScript AST generated by `acorn.parse()`
// pattern: our custom subtree pattern to match with the AST
// callback: `function(captureId, astNode) { ... }` invoked when `$capture:` is set on pattern
const findOneOnAcornAst = (ast, pattern, callback) => {
  const matchSubTree = (astNode, ptnNode, callbackItems) => {
    if (!astNode || !(astNode instanceof acorn.Node)) return false;

    for (let key in ptnNode) {
      if (key.startsWith('$')) continue; // our magic attribute

      if (typeof ptnNode[key] === 'string') {
        if (!astNode[key] || astNode[key] != ptnNode[key]) return false;
      }
      else if (ptnNode[key] instanceof Array) {
        if (!(astNode[key] instanceof Array)) return false;
        const allFound = ptnNode[key].every(ptnSubNode =>
          (0 <= astNode[key].findIndex(astSubNode => {
            //FIXME: we only handle `{ ... }` object on `[ ... ]` for now
            return matchSubTree(astSubNode, ptnSubNode, callbackItems);
          }))
        );
        if (!allFound) return false;
      }
      else if (typeof ptnNode[key] === 'object') {
        const matched = matchSubTree(astNode[key], ptnNode[key], callbackItems);
        if (!matched) return false;
      }
    }

    const captureId = ptnNode.$capture;
    if (captureId) {
      callbackItems.push({captureId, astNode});
    }
    return true;
  };

  let callbackQueue = [];
  const traverse = (astNode) => {
    if (!astNode || !(astNode instanceof acorn.Node)) return false;

    let callbackItems = [];
    if (matchSubTree(astNode, pattern, callbackItems)) {
      callbackQueue.push(callbackItems);
      return true;
    }

    // walk to possible children recursively
    for (let key in astNode) {
      if (astNode[key] instanceof Array) {
        const childNodes = astNode[key];
        const found = childNodes
          .filter(childNode => childNode instanceof acorn.Node)
          .some(childNode => traverse(childNode))
        if (found) return true;
      }
      else if (astNode[key] instanceof acorn.Node) {
        const childNode = astNode[key];
        if (traverse(childNode)) return true;
      }
    }
    return false;
  };

  const found = traverse(ast);
  if (found && (typeof callback === 'function')) {
    callbackQueue.forEach(cbItems => {
      cbItems.forEach(cbItem => callback(cbItem.captureId, cbItem.astNode));
    });
  }
  return found;
};


// -----------------------------------------------------------------------------


function injectCallback(script) {
  const ast = acorn.parse(script);

  // looking for `manifest.textTracks.forEach(function(...){...})`
  const pattern = {
    $capture: 'root',
    type: 'CallExpression',
    callee: {
      type: 'MemberExpression',
      object: {
        type: 'MemberExpression',
        object: {
          $capture: 'manifest',
          type: 'Identifier',
        },
        property: {
          type: 'Identifier',
          name: 'textTracks',
        },
      },
      property: {
        type: 'Identifier',
        name: 'forEach',
      },
    },
  };

  let injectionOffset, manifestIdName;
  const found = findOneOnAcornAst(ast, pattern, (captureId, astNode) => {
    if (captureId === 'root') {
      injectionOffset = astNode.start;
    }
    else if (captureId === 'manifest') {
      manifestIdName = astNode.name;
    }
  });

  if (found && (injectionOffset !== undefined)) {
    const payload = `(window.__NflxMultiSubs&&window.__NflxMultiSubs.updateManifest(a));`;
    return script.substr(0, injectionOffset) + payload + script.substr(injectionOffset);
  }
  return null;
}


// add 1080p for Chrome (ref. https://github.com/truedread/netflix-1080p)
function injectHiResHack(script) {
  const ast = acorn.parse(script);

  // looking for `uaTestResult = /CrOS/.test(a.userAgent);` and `uaTestResult && this.oo.push(x.V.TH);` in a same function
  const pattern = {
    $capture: 'root',
    type: 'FunctionDeclaration',
    body: {
      type: 'BlockStatement',
      body: [
        // expression: `uaTestResult = /CrOS/.test(a.userAgent);`
        {
          type: 'ExpressionStatement',
          expression: {
            type: 'AssignmentExpression',
            operator: '=',
            left: {
              $capture: 'uaTestResult',
              type: 'Identifier',
            },
            right: {
              type: 'CallExpression',
              callee: {
                $capture: 'CrOS',
                type: 'MemberExpression',
                object: {
                  type: 'Literal',
                  raw: '/CrOS/',
                },
              },
              arguments: [
                {
                  type: 'MemberExpression',
                  property: {
                    type: 'Identifier',
                    name: 'userAgent',
                  }
                },
              ],
            },
          },
        },

        // expression: `uaTestResult2 && this.oo.push(x.V.TH);`
        {
          type: 'ExpressionStatement',
          expression: {
            type: 'LogicalExpression',
            left: {
              $capture: 'uaTestResult2',
              type: 'Identifier',
            },
            operator: '&&',
            right: {
              $capture: 'addHiResProfile',
              type: 'CallExpression',
              callee: {
                type: 'MemberExpression',
                property: {
                  type: 'Identifier',
                  name: 'push',
                },
              },
            },
          },
        },
      ],
    },
  };

  let uaTestResult, uaTestResult2, injectionOffset, addHiResProfileExp;
  const found = findOneOnAcornAst(ast, pattern, (captureId, astNode) => {
    if (captureId === 'uaTestResult')
      uaTestResult = astNode.name;
    else if (captureId === 'uaTestResult2')
      uaTestResult2 = astNode.name;
    else if (captureId === 'addHiResProfile') {
      const expLength = (astNode.end - astNode.start);
      injectionOffset = astNode.end;
      addHiResProfileExp = script.substr(astNode.start, expLength);
    }
  });

  if ((found) && (uaTestResult !== undefined) &&
      (injectionOffset !== undefined) &&
      (addHiResProfileExp !== undefined) &&
      (uaTestResult === uaTestResult2))
  {
    const payload = `((!${uaTestResult})&&${addHiResProfileExp});`;
    if (script[injectionOffset] === ';') {
      injectionOffset = (injectionOffset + 1);
    }
    return script.substr(0, injectionOffset) + payload + script.substr(injectionOffset);
  }
  return null;
}


// -----------------------------------------------------------------------------


function patchNflxPlayerCore(script) {
  let patched = injectCallback(script);
  if (patched) {
    script = patched;
    console.log('Patched: callback');
  }
  else {
    console.error('Error: cannot inject callback');
  }

  patched = injectHiResHack(script);
  if (patched) {
    script = patched;
    console.log('Patched: hi-res hack');
  }
  else {
    console.error('Error: cannot inject hi-res hack');
  }
  return script;
}


////////////////////////////////////////////////////////////////////////////////


function mutateUrl(url) {
  const u = new URL(url);
  const doubleSlashPath = u.pathname.replace(/\//g, '//');
  const encodedPath = doubleSlashPath.replace('-', '%2d');
  const port = (uu.port || (/https:/i.test(u.protocol) ? ':443' : ':80'));
  const mutatedUrl = `${u.protocol}\/\/:@${u.host}${port}${encodedPath}#`;
  return mutatedUrl;
}


const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeName.toLowerCase() !== 'script') return;
      if (node.id !== 'player-core-js') return;

      const playerNode = node;
      let playerUrl = playerNode.getAttribute('src');
      playerNode.removeAttribute('src');
      console.log(`Intercepted: ${playerUrl}`);

      // URL looks like "https://assets.nflxext.com/en_us/ffe/player/html/cadmium-playercore-5.0008.727.011.js"
      origPlayerUrl = playerUrl;
      let match = /playercore-(\d+\.\d+\.\d+\.\d+)\.js/.exec(origPlayerUrl);
      if (match) {
        origPlayerVersion = match[1];
      }

      const _patchCodeAndLoad = (playerScript) => {
        const patched = patchNflxPlayerCore(playerScript);
        const blob = new Blob([patched], { type: 'text/javascript', });
        playerNode.setAttribute('src', URL.createObjectURL(blob));
        playerNode.addEventListener('load', () => {
          URL.revokeObjectURL(node.getAttribute('src'));
        });
      };

      // fetch original player code, and patch it!
      fetch(playerUrl).then(r => r.text()).then(body => {
        if ((typeof origPlayerVersion === 'string') &&
            (body.indexOf(origPlayerVersion) < 0))
        {
          // trying to bypass other extensinos :-)
          // they intercept the request and reply with a local patched code (likely out-dated)
          console.warn("Warning: the player might be tempered by others -- let's bypass them ^_<");

          const mutatedUrl = mutateUrl(playerUrl);
          fetch(mutatedUrl).then(r => r.text()).then(body2 => {
            if (body2.indexOf(origPlayerVersion) < 0) {
              console.warn('Warning: still got a outdated player, fine :-(');
              _patchCodeAndLoad(body); // body2 may be more corrupt
            }
            else {
              console.log('Success: got the latest official player, hehe!');
              _patchCodeAndLoad(body2);
            }
          });
        }
        else {
          _patchCodeAndLoad(body);
        }
      });

      observer.disconnect();

      // FYI to users who open the developer console
      console.log(`FYI: "net::ERR_BLOCKED_BY_CLIENT" error is intented`,
        `(for player code patching)`);
    });
  });
});
const options = { subtree: true, childList: true, };
observer.observe(document, options);

})();
